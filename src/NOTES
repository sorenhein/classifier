Cleaning up clusters
--------------------
The ends are non-decreasing, the starts are non-increasing.
First find lists that are immediate splits:
- Same length
- Same second interval
- First intervals abut
- Second interval combines the two
- Mark the first interval with a flag as a segmentation interval

Looking at two consecutive lists:
- Say there is a point of equality
  - Stop the first list at that point (2279), is it unique?
  - Stop the second list at the last such point

- If there is no equality:
  - What to do?


Nested intervals:
- One example sensor34 182137
- Another     sensor00 051045
- When looking for the quiet interval, we want
  left peak as negative as possible
  right peak ditto
  mid level as close to 0 while negative as possible
  but this is not enough
- something to do with sharpness of border peaks?  But speed-dependent





Even after purify:
- Start from the periodic cluster and the best cluster
- Move out best dips that are very shallow into catch-all
- Move in dips that would fit with the periodicity and are not shallow
- Look at "interval peaks" between best dips in pieces where
  the periodicity is good
- Construct a wagon with wheel numbers 1-4 and ends that are
  at the mid points / at the positive peaks in between
- 


- Pmax does not deal well with middle wagons
- Lists with wrong periods
- Create a raster and place lists relative to each other
- Also use depth as criterion
- markPossibleQuiet: Depth is always relative to prev, should
  somehow be relative to peak with lowest absolute value out of
  the two neighbors?
- Look at hand-written issues, may be a bug in purify

Prefer cluster according to score
- 10 * depth
- #per
- minus (len / (0.6 * period))^2 * 10
- Absolutely no duplicates

Look graphically for misses

Next stage: We need high-quality peaks in the open intervals.
Probably need both the streamlined peaks and the original ones.
Needs to be somewhat monotonic at the bottom.
Need the same number in each interval as a rule (often 4).
Then look in irregular internal intervals, using known spacings.
Look at the end, using known spacings.
Look at the beginning, messier.


SmallRange doesn't quite work, #23/0, #24, #25, #33/0
#28 asymm ranges pos and neg

2018-09-24
----------
- Need even cleaner peaks before we start clustering.
- s05, 053709, sample 1650: Do we have two peaks? Why not?

2018-09-23
----------
- Detect positive maxima with some streamlining (done)
- Detect negative minima with some streamlining (done)

What's left?

- Positive maxima without a negative minimum in between
  - Can be chatter
  - Can be a proper trough
- Negative minima without a positive maximum in between
  - Can be a negative maximum as a single spike
  - Can be chatter

Combine these into Pieces.

Fill in single spikes and note more complicated behavior.

By now the whole trace should be sliced up.

Look for regularities.

Fill out the complicated pieces.

2018-09-17
----------

PeakStats: 
log the category (train or sensor).
Output csv.

Give out the whole PeakList, don't copy into PeakTime?


2018-09-14
----------
We often get the 2nd of maxima above the line.  sensor34, 180956, #2.

Maybe transients can be reduced with filter padding as in filtfilt.


2018-09-02
----------
* Improve the recognition (currently 1072 / 1778 = 60.3%)

* Add separate timers for pre-align and align
* And for peak extraction

* Clean up driver.cpp

2018-07-17
----------
* Some _N and _R trains are almost impossible to separate
  - ICE4_DEU_28 is probably symmetric, in fact?
  - ICE2_DEU_48 ditto?
  - ICE1_old_CHE_56 ditto? [delete?]
  - ICE4_DEU_28 and ICET_DEU_28 have extremely similar ratios

* In doc, make the comments from Train axles.xlsx

* Files to finish:
  SynthTrain cpp and h
  driver.cpp

Visual          OK
mingw           OK
gcc
Mac gcc
Mac clang
Linux

Overall algorithm
-----------------

* Check against laser measurements!
* Output a diagram with the wagons suggested
* throw/catch with error codes (like Build)
* filtfilt padding, how?
* Make independent of sample rate (other than Butterworth?)
* Move to less padding in SegQuiet back
* Implement displacement algorithms
  - Our integration
  - Some kind of scalar product
  - Estimate parameters of the flanks?  What kind of function?
  - Also add timers
* Float (Accel) to double everywhere
* Simpson integration?
* Deconvolution of a "wheel response"?
