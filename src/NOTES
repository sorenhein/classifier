2018-09-09
----------
Probably fine:
* reduceSmallAreas(0.1f)
* eliminateKinks

Aim to have the "local" minima and also maxima in the end.
So don't eliminate positive minima as such.

Could streamline streaks of positive maxima with positive minima
in between: Just the ends and one minimum in between.
(We need good gradients.)

Estimate the area scale at this point, though of course only for
negative minima.

Eliminate small areas, but not all at once.  Start close to the previous
scale of 0.1f and gradually move up to 0.05 * scale or whatever.

Then cluster on
- level
- gradients
- lengths or areas (but only one of them)

Filter clusters on
- Tiny
- Low gradients


2018-09-02
----------
* Improve the recognition (currently 1072 / 1778 = 60.3%)

* Add separate timers for pre-align and align

* Clean up driver.cpp

2018-07-17
----------
* Some _N and _R trains are almost impossible to separate
  - ICE4_DEU_28 is probably symmetric, in fact?
  - ICE2_DEU_48 ditto?
  - ICE1_old_CHE_56 ditto? [delete?]
  - ICE4_DEU_28 and ICET_DEU_28 have extremely similar ratios

* In doc, make the comments from Train axles.xlsx

* Files to finish:
  SynthTrain cpp and h
  driver.cpp

Visual          OK
mingw           OK
gcc
Mac gcc
Mac clang
Linux

Overall algorithm
-----------------

* Check against laser measurements!
* Output a diagram with the wagons suggested
* throw/catch with error codes (like Build)
* filtfilt padding, how?
* Make independent of sample rate (other than Butterworth?)
* Move to less padding in SegQuiet back
* Implement displacement algorithms
  - Our integration
  - Some kind of scalar product
  - Estimate parameters of the flanks?  What kind of function?
  - Also add timers
* Float (Accel) to double everywhere
* Simpson integration?
