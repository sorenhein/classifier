PeakRepair:

Only missing dominance now: s30 #13, it's a mess.
======================

No model match for partial first car
======================

1, 0  Fourth wheel, but no model with ends (3):
-----
s24, #45, 201606: gaps messed up
s25, #23, 062423: gaps messed up
s28, #10, 085221: gaps messed up

0, 0  No fourth wheel, no model with ends (7):
-----
s09, #12, 075827: gaps messed up
s13, #32, 135933: somewhat messed up
s19, #19, 090921: somewhat messed up
s22, #25, 195455: gaps messed up
s30, #29, 084041: gaps messed up
s30, #40, 034724: gaps messed up
s34, #45, 170523: gaps messed up

0, 1  No fourth wheel, but model with ends (18):
-----
s04, #17, 065516 [3]: OK car (4 peaks), but peak numbering messed up
s07, # 6, 143132: gaps messed up
s10, #13, 093111 [3]: gaps messed up
s10, #19, 141941: gaps messed up
s13, #24, 065025: gaps messed up
s19, # 5, 170506: gaps messed up
s19, # 6, 064331: gaps messed up
s24, # 4, 091755: gaps messed up
s24, #13, 164601: gaps messed up
s24, #41, 134308 [3]: gaps messed up
s32, #39, 082731: 225 too close, might be transient
s34, # 2, 180956: pretty poor first peak, might be spurious


Number of anywheelers                           939
Number of zero-model fits                        28
Number of 1-4 short first cars not caught        23
Means some other methods match for                5

How often do we move peaks from used to unused in practice?
- Move them to a 3rd list and don't drop them yet
- High range, no 1234, front -> drop
- Normal range, in a hole -> odd
- Normal range, in front -> single peak +/- bogey pair?  new car? 1234?!

- See what we can slice out of WARNREPAIR to actually complete reliably

Also need to guess new models without a reference:
- We throw away some good first peaks, as the spacing isn't perfect
- Get ranges of left/right gap (as one) and bogey gap (as one)
- Store them in a symmetric CarGap?
- Use same principle (getGaps) to search?

Also:
- Use extent (later on)
- If we see a short car for the first time, look out for
  - Slightly different bogeys
  - A lot different mid gaps


* Better extent in PeakDetect
  - Both in small ranges and in kinks
* Detecting model with extent
  - Only if normal match is not enough
  - Only for those models with d < 5 (or whatever)
  - If detected, enters into model += car with modified peaks
  - Use for detecting 4-wheel cars
* Possible moves of peaks
  - Try all 4 inner moves and the right 2 outer moves.
  - Pick the single best move, see if distance is good enough
  - Keep doing?  Or just the first move?


* Pass full peaks to regression
* Also pass in choices of front changes
  - how many missing?
  - second choice (whole car missing)?
* When regression has worked
  - Adjust peak positions (same LP-type principle above)
  - Run again

* 3-wheel cars not just in 3-packs, but start or end of range
  Can utilize knowledge, e.g. 1-3-4

* 4_DEU_48_N and _R: About 30 confusions
  - Look at actual dots
  - Are the reference distances right?

* There seem to be way to many method calls during matching,
  very slow

* 1-wheel front cars: Could look at typical car spacing to see
  whether it's a 4-wheel or a 3-wheel, and if a 3-wheel, where the
  4-wheel ought to be



The regression is odd: Different penalties in first and second stage?
- s05, 183315

Unbalanced cars, but generally recognizable:
- Low and high bogey still within factor 4/3 of one another
- Distance to a car on stock (including ends) less than something
- Can shift peaks with extents to improve match

Three-peak cars
- First or last of ranges with >= 3 peaks
- Assume the two closest of 3 peaks are the bogey
- Fill in the end(s) as well
- Get list of fitting car models with optimal peak position, or
  actually the range that would still get accepted 
- If there's one in range, pick the middle one
- Value could optionally even be positive
- Now we have to synthesize the peak quality when re-inserting this
- Use the peak type (e.g. peak 3) to guess where the maxima should be
- Look for them
- Calculate qualities etc.
- Reject unless at least a good quality

One peak from first car:
- Is it already a 4?
- Or is it roughly at the right distance to the 1 of car 2?
- Is it at least a good quality?
- Could look for a peak #3 based on known cars and bogey distance
  +/- 10%
- Can we make a good-quality peak out of this as above?
- Should of course not be at negative time coordinate
- Pick the best one
- Can go on to peak #2 and #1
- See if it roughly matches 

Two or three peaks from first car:
- Same principle

Getting the gaps right
----------------------

findFirstLargeRange to process a list<Gap>&.
Stop at the first gap that meets the count goal.
Each gap is a single interval per non-zero interval in histogram.
guessNeighborDistance doesn't return a value.
If the list has length 1, it's clear.
If not, we need to try them out in order from below.
That means we look for number of pairs (each peak can only 
be used once) with good quality.
There can be other intervening peaks.



Individual cars
---------------

Later car, 4 great:
- Only if stuck (so models are stable)
- Match car with ***
- Gap difference a bit bigger, say +/- 20%
- Use the built-in extent

May have missed peaks, e.g. 3-peak car
- Go back in PeakPool
- Selectively restore some peaks
- Also applies, perhaps particularly, to first car

Efficiency
----------

Do sth about symm cars and efficiency of checking in general
- Has all four peaks, and dist(its reverse) < GREAT_DIST
- If matching two such cars, only use the forward distance


PeakStructure:
- The distance detection / peak quality may also have to go here...

Python: Allow 082401 as input?

carDetect endValue, startValue: Drop the +1, -1 stuff again, deal
with in PeakStructure?

Clean up the PPc/const nonsense in PeakPool and PeakStructure.

* PeakMinima:
  - Some TODO's (algorithmic errors, actually)
  - The second guessLongGapDistance doesn't pick up anything,
    as the second peak is always a bogey already?


2018-09-17
----------
Give out the whole PeakList, don't copy into PeakTime?
Also output the likely number of missed front peaks


2018-09-14
----------
Maybe transients can be reduced with filter padding as in filtfilt.


2018-09-02
----------
* Add separate timers for pre-align and align
* And for peak extraction

* Clean up driver.cpp

2018-07-17
----------
* Some _N and _R trains are almost impossible to separate
  - ICE4_DEU_28 is probably symmetric, in fact?
  - ICE2_DEU_48 ditto?
  - ICE1_old_CHE_56 ditto? [delete?]
  - ICE4_DEU_28 and ICET_DEU_28 have extremely similar ratios

* In doc, make the comments from Train axles.xlsx

* Files to finish:
  SynthTrain cpp and h
  driver.cpp

Visual          OK
mingw           OK
gcc
Mac gcc
Mac clang
Linux

Overall algorithm
-----------------

* Check against laser measurements!
* Output a diagram with the wagons suggested
* filtfilt padding, how?
* Make independent of sample rate (other than Butterworth?)
* Move to less padding in SegQuiet back
* Implement displacement algorithms
  - Our integration
  - Some kind of scalar product
  - Estimate parameters of the flanks?  What kind of function?
  - Also add timers
* Float (Accel) to double everywhere
* Simpson integration?
* Deconvolution of a "wheel response"?
* Move out code in driver and directories that is not used
