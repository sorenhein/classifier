2018-09-05
----------
We're getting negative areas again.

eliminateTiny does not make alternating min/max anymore


PeakDetect attempts to get the peaks almost exactly right, based on
somewhat semantic rules.  It either fails or behaves marginally w.r.t.

- Broad, symmetric minima in quiet periods, somewhat negative
- Extra, somewhat shallow but real minima during a two-wheel interval

Possible improvement:

- No runs as such

- Eliminate only very small-area peaks and only where both the left
  and right sides are small.
  - Say, all areas < (0.10, 0.10)

- Eliminate some obvious small kinks where L/R ratio > 100 (or higher?)
  on one side and maybe > 10 on the other

- Then cluster minima below the zero line, expecting
  - (Potentially) the broad, symmetric minima, not so deep
  - The actual left and right wheels (or single wheels if appropriate)
  - Some shallower but real minima that are resonances from wheels

The goal of PeakDetect has been to get the peaks almost exactly right,
i.e. all the right ones and no "spurious" ones.  This even includes
broad minima during somewhat quiet periods.  It seems that some traces
have three (noticeable) minima during ranges where there are only two
wheels.  We can try to define rules to avoid or reduce these, but it
seems difficult to make clean cuts.

Another approach is not to be too brutal about cutting peaks.  This
means we'll get the broad, quiet dips, and also the extra minima.
We won't miss quite so many peaks, except in the beginning, but we'll 
have a lot that do not directly coincide in time with wheel positions.


1. Some kind of semantic view of the peaks, similar to the human eye.
   - Only below the "zero" line?  Assumes good nulling.
   - Recognize the broad minima separately?
   - Cluster on combination of level and left-right areas?

2. Pass them all to a NW-like algorithm.  




2018-09-02
----------
* Improve the recognition (currently 1072 / 1778 = 60.3%)

* Add separate timers for pre-align and align

* Clean up driver.cpp

2018-07-17
----------
* Some _N and _R trains are almost impossible to separate
  - ICE4_DEU_28 is probably symmetric, in fact?
  - ICE2_DEU_48 ditto?
  - ICE1_old_CHE_56 ditto? [delete?]
  - ICE4_DEU_28 and ICET_DEU_28 have extremely similar ratios

* In doc, make the comments from Train axles.xlsx

* Files to finish:
  SynthTrain cpp and h
  driver.cpp

Visual          OK
mingw           OK
gcc
Mac gcc
Mac clang
Linux

Overall algorithm
-----------------

* Check against laser measurements!
* Output a diagram with the wagons suggested
* throw/catch with error codes (like Build)
* filtfilt padding, how?
* Make independent of sample rate (other than Butterworth?)
* Move to less padding in SegQuiet back
* Implement displacement algorithms
  - Our integration
  - Some kind of scalar product
  - Estimate parameters of the flanks?  What kind of function?
  - Also add timers
* Float (Accel) to double everywhere
* Simpson integration?
