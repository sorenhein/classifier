Cleaning up clusters
--------------------
Final clean-up of clusters

Score of a list of intervals
- For each interval, the lower of scores of neighbors
- OK to skip partially overlapping interval on the way to a neighbor
- Score = sum of squared distances using the period (closest multiple)

- Score of moving one or more intervals
  - Moving one out reduces score by own score, potentially neighbor scores
    change as well (or even go away)
  - Moving one in adds own score, potentially changes neighbor scores
  - Must never overlap in new cluster
  - An interval with a single entry is special

Keep an overall deviation level for the whole set of interval lists.

Iterate until done or at most 3 iterations:
- Move singles, and intervals > 3 periods from closest neighbor, 
  and intervals > 5 median deviations, to catch-up list.
  Somehow avoid moving the one we want to keep, i.e. have an idea of
  the periodic raster in the list.  Actually this is built in.
  First mark all the period matches, only consider moving singles outside of this.
- Move catch-ups to list if < 2 median deviations.
  Take smallest absolute deviation if multiple candidates.
- Move from smaller to larger if < 2 deviations in larger list


What if the two are similar, but we want bigger clusters in that case?
If the score is within the twice median deviation on both sides, prefer the
larger cluster?


- If two clusters are completely compatible
  - Look at score of merging them
- 

- Move intervals out that are not periodic
- Move intervals in that are periodic
- Recalculate dnorm etc

- Clusters should not have duplicates, other than cluster[9]
  - Use periodicity to find the problems
  - Move the aperiodic ones out
- Completely compatible clusters
  - Start from largest clusters down (no dupes only)
  - Test for periodicity of each entry from the shorter into the longer one
- Splitting clusters
  - Start from largest clusters down (no dupes only)
  - Look at small clusters and individual intervals
- Short clusters with length > 1.1 period: Delete

Look at each of the plausible "stories".
dnorm is a factor.
The average starting and ending peak is a factor:
Should be spiky.
If there are several, the one that's inside the other.



SmallRange doesn't quite work, #23/0, #24, #25, #33/0
#28 asymm ranges pos and neg

2018-09-24
----------
- Need even cleaner peaks before we start clustering.
- s05, 053709, sample 1650: Do we have two peaks? Why not?

2018-09-23
----------
- Detect positive maxima with some streamlining (done)
- Detect negative minima with some streamlining (done)

What's left?

- Positive maxima without a negative minimum in between
  - Can be chatter
  - Can be a proper trough
- Negative minima without a positive maximum in between
  - Can be a negative maximum as a single spike
  - Can be chatter

Combine these into Pieces.

Fill in single spikes and note more complicated behavior.

By now the whole trace should be sliced up.

Look for regularities.

Fill out the complicated pieces.

2018-09-17
----------
- Extract some key periodicity parameters
  - Cluster neighbors (same parameters as single peaks, but two
    together now in the distance measure), hoping to find a strong
    signal for the bogeys.  Might be two clusters or even more.
    - tentatively accepted bogeys
  - For the tentative singles, look for neighbor peaks together with 
    which they would fit a bogey cluster?
    - Look everywhere except in rejected.  Early only if it makes
      quantitative sense (how?)
  - Drop remaining singles except at the beginning and end
  

PeakStats: 
log the category (train or sensor).
Output csv.

Give out the whole PeakList, don't copy into PeakTime?


2018-09-14
----------
We often get the 2nd of maxima above the line.  sensor34, 180956, #2.

Maybe transients can be reduced with filter padding as in filtfilt.


2018-09-02
----------
* Improve the recognition (currently 1072 / 1778 = 60.3%)

* Add separate timers for pre-align and align
* And for peak extraction

* Clean up driver.cpp

2018-07-17
----------
* Some _N and _R trains are almost impossible to separate
  - ICE4_DEU_28 is probably symmetric, in fact?
  - ICE2_DEU_48 ditto?
  - ICE1_old_CHE_56 ditto? [delete?]
  - ICE4_DEU_28 and ICET_DEU_28 have extremely similar ratios

* In doc, make the comments from Train axles.xlsx

* Files to finish:
  SynthTrain cpp and h
  driver.cpp

Visual          OK
mingw           OK
gcc
Mac gcc
Mac clang
Linux

Overall algorithm
-----------------

* Check against laser measurements!
* Output a diagram with the wagons suggested
* throw/catch with error codes (like Build)
* filtfilt padding, how?
* Make independent of sample rate (other than Butterworth?)
* Move to less padding in SegQuiet back
* Implement displacement algorithms
  - Our integration
  - Some kind of scalar product
  - Estimate parameters of the flanks?  What kind of function?
  - Also add timers
* Float (Accel) to double everywhere
* Simpson integration?
