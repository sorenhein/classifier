Completions
-----------
- Classify by weight, dist, quality, used/unused/repaired

- Then when we condense
  - Identical peaks
    - If same model and reverseFlag, hence weight, get rid of one.
      For any open peaks, combine (extend) the ranges
    - If different, note both in a list, and add up weight
  - Subsumed peaks
    - For each extra peak, have a threshold for each of used/unused/...
      - dist, quality
    - If the extra peaks are OK, get rid of subsumed peaks
    - Otherwise get rid of the longer one?!
- If that is still not conclusive, look among the longest fits
  - Among the peaks that are not in common
    - Some function of dist, quality, source
  - May have completely separate ones (front and back)
    - Go by distance and quality overall of the two
- If still > 1 completion
  - What to do?
- If no completion
  - When to declare a partial match?
    - A mid should probably rarely be partial
    - A first is often a partial
    - A last is somewhere in between
  



Find the odd first cars
- s02 083643
- s03 052231


Wrong, large distances
----------------------
s03 152159 #4: A middle car 2744-3373 picks up wrong 1234 car.


General blockers
----------------
* Silent errors
  -> Reduce the residuals (< 5.00 or 10.00)
* Missing peaks
  -> More adaptive way to keep collecting peaks?
  -> Signal quality, filtering?  Simpson integration?
* Specific warnings
  -> Move even more to ByPattern, away from the hand-crafted long one
  -> sensor00 has two POSITIVE peaks at the front?  Restored perhaps?
* Three-wheel cars
  -> Detect in PeakMinima?


PeakPiece:
Do we need summary(), modality()?

Odd lengths
-  1: 11.5 out of 14 cars
-  1: 12 out of 14 cars
-  1: 60 out of 56 peaks?


Plan 2019-05-08
---------------
* Move the range.split out of each method into the overall loop?

* Too many car types sometimes, s03 201953 #36

Further:

* Extents?
* Letting regress know if last is messed up

Vision:

* Deconvolution
  - tau of trail
  - speed of train
  - physics of switch


Plan 2019-04-15
---------------
Align.cpp
- Pass in a more elaborate alignment struct
  - numFrontWheels as before, in case nothing else suits
  - struct: noObs, noRef, flag
  - One for the first, middle and last peak that we assume

ByGeometry in PeakStructure: Probably should check that there
aren't two peaks in the middle with good spacing.

Plan 2019-02-27
---------------
Work on split peaks
- Once bogie distance is determined, combine some peaks
- But there could be so many that we end up combining p1 and p2?
- Need to log extent of removed peaks as well

Two candidates in locatePeak: Could well both be true if greatQuality.

Look at the ones with no left-over PeakPtrsUsed: repair.
Also the ones with incomplete PeakPtrsUsed repair can be repaired.
(s23 #33)

Also:
- Use extent (later on)
- If we see a short car for the first time, look out for
  - Slightly different bogeys
  - A lot different mid gaps

* Better extent in PeakDetect
  - Both in small ranges and in kinks
* Detecting model with extent
  - Only if normal match is not enough
  - Only for those models with d < 5 (or whatever)
  - If detected, enters into model += car with modified peaks
  - Use for detecting 4-wheel cars
* Possible moves of peaks
  - Try all 4 inner moves and the right 2 outer moves.
  - Pick the single best move, see if distance is good enough
  - Keep doing?  Or just the first move?

* Pass full peaks to regression
* Also pass in choices of front changes
  - how many missing?
  - second choice (whole car missing)?
* When regression has worked
  - Adjust peak positions (same LP-type principle above)
  - Run again
  - Take into account extent?

* 3-wheel cars not just in 3-packs, but start or end of range
  Can utilize knowledge, e.g. 1-3-4

* Time profile of recognizers etc., speed up


The regression is odd: Different penalties in first and second stage?
- s05, 183315

Three-peak cars
- First or last of ranges with >= 3 peaks
- Assume the two closest of 3 peaks are the bogey
- Fill in the end(s) as well
- Get list of fitting car models with optimal peak position, or
  actually the range that would still get accepted 
- If there's one in range, pick the middle one
- Value could optionally even be positive
- Now we have to synthesize the peak quality when re-inserting this
- Use the peak type (e.g. peak 3) to guess where the maxima should be
- Look for them
- Calculate qualities etc.
- Reject unless at least a good quality

Getting the gaps right
----------------------

findFirstLargeRange to process a list<Gap>&.
Stop at the first gap that meets the count goal.
Each gap is a single interval per non-zero interval in histogram.
guessNeighborDistance doesn't return a value.
If the list has length 1, it's clear.
If not, we need to try them out in order from below.
That means we look for number of pairs (each peak can only 
be used once) with good quality.
There can be other intervening peaks.


Efficiency
----------

Do sth about symm cars and efficiency of checking in general
- Has all four peaks, and dist(its reverse) < GREAT_DIST
- If matching two such cars, only use the forward distance
- Keep cars symmetrical that are meant to be so


PeakStructure:
- The distance detection / peak quality may also have to go here...

Python: Allow 082401 as input?

carDetect endValue, startValue: Drop the +1, -1 stuff again, deal
with in PeakStructure?

Clean up the PPc/const nonsense in PeakPool and PeakStructure.

* PeakMinima:
  - Some TODO's (algorithmic errors, actually)
  - The second guessLongGapDistance doesn't pick up anything,
    as the second peak is always a bogey already?


2018-09-17
----------
Give out the whole PeakList, don't copy into PeakTime?


2018-09-14
----------
Maybe transients can be reduced with filter padding as in filtfilt.


2018-09-02
----------
* Add separate timers for pre-align and align
* And for peak extraction

* Clean up driver.cpp
* Move out ckmeans code

2018-07-17
----------
Visual          OK 2019-05-28
gcc             OK 2019-05-28

mingw           OK 2018-07-17
Mac gcc
Mac clang
Linux

Overall algorithm
-----------------

* Check against laser measurements!
* Output a diagram with the wagons suggested
* filtfilt padding, how?
* Make independent of sample rate (other than Butterworth?)
* Move to less padding in SegQuiet back
* Implement displacement algorithms
  - Our integration
  - Some kind of scalar product
  - Estimate parameters of the flanks?  What kind of function?
  - Also add timers
* Float (Accel) to double everywhere
* Simpson integration?
* Deconvolution of a "wheel response"?
* Move out code in driver and directories that is not used

* Could have an average time delay or number of peaks missed by
  a given sensor.  See DEU_32.docx

* Missing a train type?  
  - sensor07 #1  173201.  30 of 32(?) peaks.

  - sensor27 #10 194415.  48 of 48(?) peaks.
    ICE1_DEU_52_N, symmetric: Consider to add this

Peak/car trouble in well-matching solutions:
s03, 173935, #31, 26.11
s07, 085335, #16,  0.28
s10, 200750, #32,  2.47
s19, 084253, #24,  0.83
s27, 194725, #29,  1.73

Peak/car trouble in poorly-matching but correct solutions:
s03, 085719, #28,  37.16
s04, 103039, # 8, 155.84
s08, 202150, #49,  12.34
s13, 083756, #17,  30.39
s18, 094628, #29, 177.77
s18, 185755, #30,   9.66
s18, 063210, #35,  15.65
s18, 075954, #42,  22.96
s18, 174241, #47, 238.43
s20, 102050, #41,   9.33
s21, 094236, #46,  27.75


Write a detector of unused class methods.
