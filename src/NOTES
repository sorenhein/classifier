Remaining issues with the "good" traces
---------------------------------------
* Once 29 peaks does not seem right
* Zero middle cars
* Sort on whole distance?
* Clean up DynProg
  - Only go +/- 10 peaks or so
  - Note whether alignment has changed
* Align
  - Only rerun regression if alignment has changed
  - If N-W residuals too high, maybe no regression as well
* In Align, note decisions that are close, even if they are resolved
* Post-process to drop unusually large residuals?

Distinguisher in Align.cpp
--------------------------
- second >= 2, second/first >= 5: consider first to win: 923 / 2
- first >= 5: consider as large: 37 / 16
- rest: look more closely

Output results from Perl overview into csv:
- Safe: OK, NOK
- Close: OK, NOK
- Far off: OK, NOK

For the close ones:
- Look at Linf norm, Linf avg of top 3 or #3, L1 sum of all
- Probably it's best to have relatively even residuals and not
  a few poking out
- The better solution would be the car pattern

Trains
------
* Seems there is a "resonance" around 150-160 km/h (42-45 m/s)
* It widens the distance within a 2500mm bogie at the expense of 
  surrounding distances
* It also works for 3000mm at 180-190 km/h (50-53 m/s)
* Could have train templates at different speeds
* Or could look for pattern, clusters:
  short bogie - long - short etc.
  More of a morphological match
* Maybe look at the car clusters
* When matching, say, 30 peaks:
  - If fine quality, it should cost a lot to discard them
* Will need to deconvolve in the end?


Align
-----
- Do we need printVectorCSV from util/misc.h? --> sstream

* Shouldn't all full recognitions be perfect?
  - no errors
  - low distances

* Guess axles of 64-wheel ICE.

* When new filter loses, is it also on the "good" traces?

* If multi-threading, at the end add up the thread stats into an
  overall stat.  Or keep them together to begin with.  Then mutex.



continue with run.cpp
---------------------
global array of output files, indexed by thid
output not to cout but to files there
only output timing to cout
reover.pl to summarize from there instead
delete directory contents every time before running
summarize.pl to reorder by file number to have same order always
outputs to be systematically controlled by flags

Multi-threading
---------------
Need vector of ofstreams in driver.cpp
* Names are sensor00_0.txt etc.
* Locations are in output
* control file dictates output file name

Need scripts that are 
* Executable
* Not in src (change path)

Improvements
------------
Warnings
- Look at spacing (call it "Final"?)
- Look at other issues
Number of models
Exceptions
Large distances

Does Align work for partial lasts?

Too many car models
- Count car models
- Count targets in PeakPattern

Wrong, large distances
----------------------
s03 152159 #4: A middle car 2744-3373 picks up wrong 1234 car.


General blockers
----------------
* Silent errors
  -> Reduce the residuals (< 5.00 or 10.00)
* Missing peaks
  -> More adaptive way to keep collecting peaks?
  -> Signal quality, filtering?  Simpson integration?
* Three-wheel cars
  -> Detect in PeakMinima?

PeakPiece:
Do we need summary(), modality()?

Odd lengths
-  1: 11.5 out of 14 cars (too long transient?!)
-  1: 12 out of 14 cars
-  1: 60 out of 56 peaks?


Plan 2019-05-08
---------------
* Move the range.split out of each method into the overall loop?

* Too many car types sometimes, s03 201953 #36

Further:

* Extents?
* Letting regress know if last is messed up

Vision:

* Deconvolution
  - tau of trail
  - speed of train
  - physics of switch


Plan 2019-02-27
---------------
Work on split peaks
- Once bogie distance is determined, combine some peaks
- But there could be so many that we end up combining p1 and p2?
- Need to log extent of removed peaks as well

Two candidates in locatePeak: Could well both be true if greatQuality.

Look at the ones with no left-over PeakPtrsUsed: repair.
Also the ones with incomplete PeakPtrsUsed repair can be repaired.
(s23 #33)

Also:
- Use extent (later on)
- If we see a short car for the first time, look out for
  - Slightly different bogeys
  - A lot different mid gaps

* Better extent in PeakDetect
  - Both in small ranges and in kinks
* Detecting model with extent
  - Only if normal match is not enough
  - Only for those models with d < 5 (or whatever)
  - If detected, enters into model += car with modified peaks
  - Use for detecting 4-wheel cars
* Possible moves of peaks
  - Try all 4 inner moves and the right 2 outer moves.
  - Pick the single best move, see if distance is good enough
  - Keep doing?  Or just the first move?

* Pass full peaks to regression
* Also pass in choices of front changes
  - how many missing?
  - second choice (whole car missing)?
* When regression has worked
  - Adjust peak positions (same LP-type principle above)
  - Run again
  - Take into account extent?

* 3-wheel cars not just in 3-packs, but start or end of range
  Can utilize knowledge, e.g. 1-3-4

* Time profile of recognizers etc., speed up

Three-peak cars
- First or last of ranges with >= 3 peaks
- Assume the two closest of 3 peaks are the bogey
- Fill in the end(s) as well
- Get list of fitting car models with optimal peak position, or
  actually the range that would still get accepted 
- If there's one in range, pick the middle one
- Value could optionally even be positive
- Now we have to synthesize the peak quality when re-inserting this
- Use the peak type (e.g. peak 3) to guess where the maxima should be
- Look for them
- Calculate qualities etc.
- Reject unless at least a good quality

Getting the gaps right
----------------------

findFirstLargeRange to process a list<Gap>&.
Stop at the first gap that meets the count goal.
Each gap is a single interval per non-zero interval in histogram.
guessNeighborDistance doesn't return a value.
If the list has length 1, it's clear.
If not, we need to try them out in order from below.
That means we look for number of pairs (each peak can only 
be used once) with good quality.
There can be other intervening peaks.


Efficiency
----------

Do sth about symm cars and efficiency of checking in general
- Has all four peaks, and dist(its reverse) < GREAT_DIST
- If matching two such cars, only use the forward distance
- Keep cars symmetrical that are meant to be so


PeakStructure:
- The distance detection / peak quality may also have to go here...

Python: Allow 082401 as input?

carDetect endValue, startValue: Drop the +1, -1 stuff again, deal
with in PeakStructure?

Clean up the PPc/const nonsense in PeakPool and PeakStructure.

* PeakMinima:
  - Some TODO's (algorithmic errors, actually)
  - The second guessLongGapDistance doesn't pick up anything,
    as the second peak is always a bogey already?


2018-09-14
----------
Maybe transients can be reduced with filter padding as in filtfilt.


2018-07-17
----------
Visual          OK 2019-05-28
gcc             OK 2019-05-28

mingw           OK 2018-07-17
Mac gcc
Mac clang
Linux

Overall algorithm
-----------------

* Check against laser measurements!
* Output a diagram with the wagons suggested
* filtfilt padding, how?
* Make independent of sample rate (other than Butterworth?)
* Move to less padding in SegQuiet back
* Implement displacement algorithms
  - Our integration
  - Some kind of scalar product
  - Estimate parameters of the flanks?  What kind of function?
  - Also add timers
* Float (Accel) to double everywhere
* Simpson integration?
* Deconvolution of a "wheel response"?
* Move out code in driver and directories that is not used

* Could have an average time delay or number of peaks missed by
  a given sensor.  See DEU_32.docx

* Missing a train type?  
  - sensor07 #1  173201.  30 of 32(?) peaks.

  - sensor27 #10 194415.  48 of 48(?) peaks.
    ICE1_DEU_52_N, symmetric: Consider to add this

Peak/car trouble in well-matching solutions:
s03, 173935, #31, 26.11
s07, 085335, #16,  0.28
s10, 200750, #32,  2.47
s19, 084253, #24,  0.83
s27, 194725, #29,  1.73

Peak/car trouble in poorly-matching but correct solutions:
s03, 085719, #28,  37.16
s04, 103039, # 8, 155.84
s08, 202150, #49,  12.34
s13, 083756, #17,  30.39
s18, 094628, #29, 177.77
s18, 185755, #30,   9.66
s18, 063210, #35,  15.65
s18, 075954, #42,  22.96
s18, 174241, #47, 238.43
s20, 102050, #41,   9.33
s21, 094236, #46,  27.75


Write a detector of unused class methods.
