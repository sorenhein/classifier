* Better extent in PeakDetect
  - Both in small ranges and in kinks
* Detecting model with extent
  - Only if normal match is not enough
  - Only for those models with d < 3 (or whatever)
  - If detected, enters into model += car with modified peaks
  - Use for detecting 4-wheel cars
* Choose delta to center first detected peak on expected peak
* There's a gradient on delta moving either way
  - Within an interval, 0
  - When an interval is moving closer: dist^2, gradient +2 dist
  - When an interval is moving away: dist^2, gradient -2 dist
  - Can keep going until hitting an edge
  - Find the lowest (local) delta or range
  - Pick the middle one if there's a choice
  - Note the adjusted peaks within their extents
  - Calculate the usual car-model distance
  - Note the adjusted car, but don't change the peaks

* Pass full peaks to regression
* Also pass in choices of front changes
  - how many missing?
  - second choice (whole car missing)?
* When regression has worked
  - Adjust peak positions (same LP-type principle above)
  - Run again

* 3-wheel cars not just in 3-packs, but start or end of range

* 4_DEU_48_N and _R: About 30 confusions
  - Look at actual dots
  - Are the reference distances right?

* There seem to be way to many method calls during matching,
  very slow

* 1-wheel front cars: Could look at typical car spacing to see
  whether it's a 4-wheel or a 3-wheel, and if a 3-wheel, where the
  4-wheel ought to be



The regression is odd: Different penalties in first and second stage?
- s05, 183315

Do not count mismatches between 4_48_N and 4_48_R when both are < 1.00
(still show them separately, or just count them up).

Later on, make better averages of these two types.

Unbalanced cars, but generally recognizable:
- Low and high bogey still within factor 4/3 of one another
- Distance to a car on stock (including ends) less than something
- Can shift peaks with extents to improve match

Three-peak cars
- First or last of ranges with >= 3 peaks
- Assume the two closest of 3 peaks are the bogey
- Fill in the end(s) as well
- Get list of fitting car models with optimal peak position, or
  actually the range that would still get accepted 
- If there's one in range, pick the middle one
- Value could optionally even be positive
- Now we have to synthesize the peak quality when re-inserting this
- Use the peak type (e.g. peak 3) to guess where the maxima should be
- Look for them
- Calculate qualities etc.
- Reject unless at least a good quality

One peak from first car:
- Is it already a 4?
- Or is it roughly at the right distance to the 1 of car 2?
- Is it at least a good quality?
- Could look for a peak #3 based on known cars and bogey distance
  +/- 10%
- Can we make a good-quality peak out of this as above?
- Should of course not be at negative time coordinate
- Pick the best one
- Can go on to peak #2 and #1
- See if it roughly matches 

Two or three peaks from first car:
- Same principle

Getting the gaps right
----------------------

findFirstLargeRange to process a list<Gap>&.
Stop at the first gap that meets the count goal.
Each gap is a single interval per non-zero interval in histogram.
guessNeighborDistance doesn't return a value.
If the list has length 1, it's clear.
If not, we need to try them out in order from below.
That means we look for number of pairs (each peak can only 
be used once) with good quality.
There can be other intervening peaks.



Individual cars
---------------

Later car, 4 great:
- Only if stuck (so models are stable)
- Match car with ***
- Gap difference a bit bigger, say +/- 20%
- Use the built-in extent

May have missed peaks, e.g. 3-peak car
- Go back in PeakPool
- Selectively restore some peaks
- Also applies, perhaps particularly, to first car

Efficiency
----------

Do sth about symm cars and efficiency of checking in general
- Has all four peaks, and dist(its reverse) < GREAT_DIST
- If matching two such cars, only use the forward distance


ByQuality is in an in-between state.  Either turn on or delete.

PeakStructure:
- The distance detection / peak quality may also have to go here...

Python: Allow 082401 as input?

carDetect endValue, startValue: Drop the +1, -1 stuff again, deal
with in PeakStructure?

MISMATCH in "good" sensors:

sensor
sensor02        162222  #41     First car: Get 2 last peaks, not 1 last

sensor03        081132  #8      Inner: Only 3 peaks
                052036  #10     First 10 peaks: Take from behind
                                Inner: Only 3 peaks
                193754  #16     First: 1, maybe 2 peaks
                                Last: 5 peaks, 2 mislabeled early (new car)
                061240  #19     Whole front car missing! Close 4_48_{N,R}
                085719  #28     First: 4 great peaks (new car)
                                Inner: Only 3 peaks (twice)
                                Last: 4 great peaks (new car)
                173935  #31     First: 2 great peaks
                                Inner: Only 3 peaks
                                Last: 7 peaks = 3 + 4 great ones

sensor04        073931  #7      Wrong short gap, in-between neg. minimum!
sensor06        115207  #34     ICE4_DEU_48_{N,R} extremely similar

Clean up the PPc/const nonsense in PeakPool and PeakStructure.

* PeakMinima:
  - Some TODO's (algorithmic errors, actually)
  - The second guessLongGapDistance doesn't pick up anything,
    as the second peak is always a bogey already?


2018-09-17
----------
Give out the whole PeakList, don't copy into PeakTime?
Also output the likely number of missed front peaks


2018-09-14
----------
Maybe transients can be reduced with filter padding as in filtfilt.


2018-09-02
----------
* Add separate timers for pre-align and align
* And for peak extraction

* Clean up driver.cpp

2018-07-17
----------
* Some _N and _R trains are almost impossible to separate
  - ICE4_DEU_28 is probably symmetric, in fact?
  - ICE2_DEU_48 ditto?
  - ICE1_old_CHE_56 ditto? [delete?]
  - ICE4_DEU_28 and ICET_DEU_28 have extremely similar ratios

* In doc, make the comments from Train axles.xlsx

* Files to finish:
  SynthTrain cpp and h
  driver.cpp

Visual          OK
mingw           OK
gcc
Mac gcc
Mac clang
Linux

Overall algorithm
-----------------

* Check against laser measurements!
* Output a diagram with the wagons suggested
* filtfilt padding, how?
* Make independent of sample rate (other than Butterworth?)
* Move to less padding in SegQuiet back
* Implement displacement algorithms
  - Our integration
  - Some kind of scalar product
  - Estimate parameters of the flanks?  What kind of function?
  - Also add timers
* Float (Accel) to double everywhere
* Simpson integration?
* Deconvolution of a "wheel response"?
* Move out code in driver and directories that is not used
