get rid of Imperf
output not to cout but to files there
only output timing to cout
reover.pl to summarize from there instead
delete directory contents every time before running
summarize.pl to reorder by file number to have same order always
outputs to be systematically controlled by flags
rip out transient into a directory
global array out output files, indexed by thid

Multi-threading
---------------
Need vector of ofstreams in control2
* Names are sensor00_0.txt etc.
* Locations are in output

Need scripts that are 
* Executable
* Not in src (change path)

Directories
-----------
transient, split out from trace


cout more localized, not in parse.cpp but in the callers

Difference in results between laptop and PC?  Always?!

Improvements
------------
Warnings
- Look at spacing (call it "Final"?)
- Look at other issues
Number of models
Exceptions
Large distances

Scan sensor??.txt for large numbers in general.
- sensor19, 134730: Same peak twice in a completion.

Does Align work for partial lasts?

Too many car models
- Count car models
- Count targets in PeakPattern

Wrong, large distances
----------------------
s03 152159 #4: A middle car 2744-3373 picks up wrong 1234 car.


General blockers
----------------
* Silent errors
  -> Reduce the residuals (< 5.00 or 10.00)
* Missing peaks
  -> More adaptive way to keep collecting peaks?
  -> Signal quality, filtering?  Simpson integration?
* Three-wheel cars
  -> Detect in PeakMinima?

PeakPiece:
Do we need summary(), modality()?

Odd lengths
-  1: 11.5 out of 14 cars
-  1: 12 out of 14 cars
-  1: 60 out of 56 peaks?


Plan 2019-05-08
---------------
* Move the range.split out of each method into the overall loop?

* Too many car types sometimes, s03 201953 #36

Further:

* Extents?
* Letting regress know if last is messed up

Vision:

* Deconvolution
  - tau of trail
  - speed of train
  - physics of switch


Plan 2019-04-15
---------------
Align.cpp
- Pass in a more elaborate alignment struct
  - numFrontWheels as before, in case nothing else suits
  - struct: noObs, noRef, flag
  - One for the first, middle and last peak that we assume

Plan 2019-02-27
---------------
Work on split peaks
- Once bogie distance is determined, combine some peaks
- But there could be so many that we end up combining p1 and p2?
- Need to log extent of removed peaks as well

Two candidates in locatePeak: Could well both be true if greatQuality.

Look at the ones with no left-over PeakPtrsUsed: repair.
Also the ones with incomplete PeakPtrsUsed repair can be repaired.
(s23 #33)

Also:
- Use extent (later on)
- If we see a short car for the first time, look out for
  - Slightly different bogeys
  - A lot different mid gaps

* Better extent in PeakDetect
  - Both in small ranges and in kinks
* Detecting model with extent
  - Only if normal match is not enough
  - Only for those models with d < 5 (or whatever)
  - If detected, enters into model += car with modified peaks
  - Use for detecting 4-wheel cars
* Possible moves of peaks
  - Try all 4 inner moves and the right 2 outer moves.
  - Pick the single best move, see if distance is good enough
  - Keep doing?  Or just the first move?

* Pass full peaks to regression
* Also pass in choices of front changes
  - how many missing?
  - second choice (whole car missing)?
* When regression has worked
  - Adjust peak positions (same LP-type principle above)
  - Run again
  - Take into account extent?

* 3-wheel cars not just in 3-packs, but start or end of range
  Can utilize knowledge, e.g. 1-3-4

* Time profile of recognizers etc., speed up

Three-peak cars
- First or last of ranges with >= 3 peaks
- Assume the two closest of 3 peaks are the bogey
- Fill in the end(s) as well
- Get list of fitting car models with optimal peak position, or
  actually the range that would still get accepted 
- If there's one in range, pick the middle one
- Value could optionally even be positive
- Now we have to synthesize the peak quality when re-inserting this
- Use the peak type (e.g. peak 3) to guess where the maxima should be
- Look for them
- Calculate qualities etc.
- Reject unless at least a good quality

Getting the gaps right
----------------------

findFirstLargeRange to process a list<Gap>&.
Stop at the first gap that meets the count goal.
Each gap is a single interval per non-zero interval in histogram.
guessNeighborDistance doesn't return a value.
If the list has length 1, it's clear.
If not, we need to try them out in order from below.
That means we look for number of pairs (each peak can only 
be used once) with good quality.
There can be other intervening peaks.


Efficiency
----------

Do sth about symm cars and efficiency of checking in general
- Has all four peaks, and dist(its reverse) < GREAT_DIST
- If matching two such cars, only use the forward distance
- Keep cars symmetrical that are meant to be so


PeakStructure:
- The distance detection / peak quality may also have to go here...

Python: Allow 082401 as input?

carDetect endValue, startValue: Drop the +1, -1 stuff again, deal
with in PeakStructure?

Clean up the PPc/const nonsense in PeakPool and PeakStructure.

* PeakMinima:
  - Some TODO's (algorithmic errors, actually)
  - The second guessLongGapDistance doesn't pick up anything,
    as the second peak is always a bogey already?


2018-09-17
----------
Give out the whole PeakList, don't copy into PeakTime?


2018-09-14
----------
Maybe transients can be reduced with filter padding as in filtfilt.


2018-09-02
----------
* Add separate timers for pre-align and align
* And for peak extraction

* Clean up driver.cpp

2018-07-17
----------
Visual          OK 2019-05-28
gcc             OK 2019-05-28

mingw           OK 2018-07-17
Mac gcc
Mac clang
Linux

Overall algorithm
-----------------

* Check against laser measurements!
* Output a diagram with the wagons suggested
* filtfilt padding, how?
* Make independent of sample rate (other than Butterworth?)
* Move to less padding in SegQuiet back
* Implement displacement algorithms
  - Our integration
  - Some kind of scalar product
  - Estimate parameters of the flanks?  What kind of function?
  - Also add timers
* Float (Accel) to double everywhere
* Simpson integration?
* Deconvolution of a "wheel response"?
* Move out code in driver and directories that is not used

* Could have an average time delay or number of peaks missed by
  a given sensor.  See DEU_32.docx

* Missing a train type?  
  - sensor07 #1  173201.  30 of 32(?) peaks.

  - sensor27 #10 194415.  48 of 48(?) peaks.
    ICE1_DEU_52_N, symmetric: Consider to add this

Peak/car trouble in well-matching solutions:
s03, 173935, #31, 26.11
s07, 085335, #16,  0.28
s10, 200750, #32,  2.47
s19, 084253, #24,  0.83
s27, 194725, #29,  1.73

Peak/car trouble in poorly-matching but correct solutions:
s03, 085719, #28,  37.16
s04, 103039, # 8, 155.84
s08, 202150, #49,  12.34
s13, 083756, #17,  30.39
s18, 094628, #29, 177.77
s18, 185755, #30,   9.66
s18, 063210, #35,  15.65
s18, 075954, #42,  22.96
s18, 174241, #47, 238.43
s20, 102050, #41,   9.33
s21, 094236, #46,  27.75


Write a detector of unused class methods.
