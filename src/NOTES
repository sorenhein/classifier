Quiet.cpp
- Grading should be in 3, not 4
- Called GREEN, AMBER, RED
- MEAN_SOMEWHAT_QUIET is absolute
- MEAN_QUIET_LIMIT is a multiple of this (1.5)
- When doing quiet small periods, estimate sdev of these
  - Make 100 * sdev list
  - Pass to PeakPieces
  - PeakPieces becomes more general, constants not hardwired,
    passed in instead
  - One set for gaps
  - Another set for quiet periods

cluster/Primary.cpp is part of PeakPieces.cpp
cluster/Piece.cpp is PeakPiece.cpp
Then use this in Quiet.cpp


Acceleration-based detection
----------------------------
* Running-average 9-tap filter on raw acceleration
* For an assumed train type
  - Cut out 2-bogie 4-wheel segments, noting
    - Bogie distance, left and right
    - My suggested peak positions
    - Be generous with left and right quiet periods
  - For each bogie length (use true train)
    - Average of isolated, left, right instances with counts
  - (Use the averages to estimate quiet periods
    - Cut them away, leaving a bit of constant tail)
  - Use above to guess a good left side and right side of that bogie
    - Still use MA-9 average, or the original, noisy signal?
    - For the alignment, have a quality metric
  - Use these guesses to subtract out the irrelevant half of
    each 2-bogie pair and estimate the other bogie, which will
    have a good side and a dubious one
    Average the types separately (both sides good, only one side
    good, so three types; count them)
  - Guess preliminary wheel core pattern in a bogie by
    - Spacing between peaks
    - Zero-crossings and slopes
    - Energy in signal between the zero-crossings
    - Can be different wheel for different bogie lengths!
  - Correlate for the preliminary wheel core pattern in each
    of the above bogies
  - Make a synthetic bogie estimate for a given length
    - Count everything from a good-good bogie
    - Count up to the zero-crossing coming down from the first
      peak if bad-good, assuming transients to be small by then
    - Similarly for good-bad
  - Output
    - Peak positions -> Align.cpp again
      - In Align, use peak positions (store in Alignment)
        and not getIndex()
    - The synthetic bogie estimate, with count (left/right
      contributions separately) for each bogie distance
    - The wheel profile in each bogie type
    - Are the wheel profiles the same?
* What train type wins?

* Could maybe detect peaks directly from acceleration trace (MA9)
  - Look for the largest peak-peak segments
  - Look at their slopes as well
  - Sort these zero-crossings by something
    - Want high range
    - Want short time
    - Want high slope
    - Slope * range = range^2 / time
    - Wants pairs of characteristic distance, one up and one down
  - See if we can bootstrap into pairs
  - See if we can get the wheel core pattern
  - See if we can correlate for this
-- Probably not robust enough

* Another way, non-parametric largely
  - Divide trace up into active regions
  - Generally these will contain 2 or 4 wheels (1 or 2 bogies)
  - For each quiet segment
    - Auto-correlate for shifts around the middle of the length
    - Both forward and backward
    - Probably yields some good matches relative to energy of
      whole auto-correlation / 2
    - Make a synthetic half segment using the leading edge of the
      left half and the trailing edge of the right half
    - Now we either have a wheel or a bogie -- don't know yet
    - Could integrate up and count position peaks?
    - Some will not match so well, e.g. 2300 - gap - 2600
  - Take stock of what we've found, combine some pieces, average them etc.
  - Take a reliable piece and attempt to guess wheel
  - Once we have a plausible core wheel, correlate for it everywhere

Actually, maybe we can classify more or less on bogies, not on wheels?!
* After Quiet.cpp, do something similar to get all the quiet periods
  that we can find *within* the signal
  - Active period
    start
    likely real start (finetuned)
    end
    likely real end (finetuned)
    list of peaks in double integral, forced to 0 at both ends
    should be 2 or 4


Studying the bogies:
* Effect of train speed?
* Effect of bogie distance?
* Is the bogie response asymmetric in time?  (Probably)
* What causes the two micro-peaks in a wheel peak, and are there
  always two?
  - Could it be that the sleeper "hits" something on either side
    at slightly different times?
  - Can damping or moving-mass yield the double dip?
    - What is 2nd derivative of position of the analytical solution
      with Pasternak soil and moving load?
* Check literature list of Alam Uzzal, Bhat, Ahmed (Dynamic response
  of a beam subjected to moving load and moving mass supported by
  Pasternak foundation)


Remaining issues with the "good" traces
---------------------------------------
* Once 29 peaks does not seem right
* Zero middle cars
* In Align, note decisions that are close, even if they are resolved
* Post-process to drop unusually large residuals?

Distinguisher in Align.cpp
--------------------------
- second >= 2, second/first >= 5: consider first to win: 923 / 2
- first >= 5: consider as large: 37 / 16
- rest: look more closely

Output results from Perl overview into csv:
- Safe: OK, NOK
- Close: OK, NOK
- Far off: OK, NOK

For the close ones:
- Look at Linf norm, Linf avg of top 3 or #3, L1 sum of all
- Probably it's best to have relatively even residuals and not
  a few poking out
- The better solution would be the car pattern

Trains
------
* Seems there is a "resonance" around 150-160 km/h (42-45 m/s)
* It widens the distance within a 2500mm bogie at the expense of 
  surrounding distances
* It also works for 3000mm at 180-190 km/h (50-53 m/s)
* Could have train templates at different speeds
* Or could look for pattern, clusters:
  short bogie - long - short etc.
  More of a morphological match
* Maybe look at the car clusters
* When matching, say, 30 peaks:
  - If fine quality, it should cost a lot to discard them
* Will need to deconvolve in the end?


Align
-----
- Do we need printVectorCSV from util/misc.h? --> sstream

* Shouldn't all full recognitions be perfect?
  - no errors
  - low distances

* Guess axles of 64-wheel ICE.

* When new filter loses, is it also on the "good" traces?

* If multi-threading, at the end add up the thread stats into an
  overall stat.  Or keep them together to begin with.  Then mutex.



continue with run.cpp
---------------------
global array of output files, indexed by thid
output not to cout but to files there
only output timing to cout
reover.pl to summarize from there instead
delete directory contents every time before running
summarize.pl to reorder by file number to have same order always
outputs to be systematically controlled by flags

Multi-threading
---------------
Need vector of ofstreams in driver.cpp
* Names are sensor00_0.txt etc.
* Locations are in output
* control file dictates output file name

Need scripts that are 
* Executable
* Not in src (change path)

Improvements
------------
Warnings
- Look at spacing (call it "Final"?)
- Look at other issues
Number of models
Exceptions
Large distances

Does Align work for partial lasts?

Too many car models
- Count car models
- Count targets in PeakPattern

Wrong, large distances
----------------------
s03 152159 #4: A middle car 2744-3373 picks up wrong 1234 car.


General blockers
----------------
* Silent errors
  -> Reduce the residuals (< 5.00 or 10.00)
* Missing peaks
  -> More adaptive way to keep collecting peaks?
  -> Signal quality, filtering?  Simpson integration?
* Three-wheel cars
  -> Detect in PeakMinima?

PeakPiece:
Do we need summary(), modality()?

Odd lengths
-  1: 11.5 out of 14 cars (too long transient?!)
-  1: 12 out of 14 cars
-  1: 60 out of 56 peaks?


Plan 2019-05-08
---------------
* Move the range.split out of each method into the overall loop?

* Too many car types sometimes, s03 201953 #36

Further:

* Extents?
* Letting regress know if last is messed up

Vision:

* Deconvolution
  - tau of trail
  - speed of train
  - physics of switch


Plan 2019-02-27
---------------
Work on split peaks
- Once bogie distance is determined, combine some peaks
- But there could be so many that we end up combining p1 and p2?
- Need to log extent of removed peaks as well

Two candidates in locatePeak: Could well both be true if greatQuality.

Look at the ones with no left-over PeakPtrsUsed: repair.
Also the ones with incomplete PeakPtrsUsed repair can be repaired.
(s23 #33)

Also:
- Use extent (later on)
- If we see a short car for the first time, look out for
  - Slightly different bogeys
  - A lot different mid gaps

* Better extent in PeakDetect
  - Both in small ranges and in kinks
* Detecting model with extent
  - Only if normal match is not enough
  - Only for those models with d < 5 (or whatever)
  - If detected, enters into model += car with modified peaks
  - Use for detecting 4-wheel cars
* Possible moves of peaks
  - Try all 4 inner moves and the right 2 outer moves.
  - Pick the single best move, see if distance is good enough
  - Keep doing?  Or just the first move?

* Pass full peaks to regression
* Also pass in choices of front changes
  - how many missing?
  - second choice (whole car missing)?
* When regression has worked
  - Adjust peak positions (same LP-type principle above)
  - Run again
  - Take into account extent?

* 3-wheel cars not just in 3-packs, but start or end of range
  Can utilize knowledge, e.g. 1-3-4

* Time profile of recognizers etc., speed up

Three-peak cars
- First or last of ranges with >= 3 peaks
- Assume the two closest of 3 peaks are the bogey
- Fill in the end(s) as well
- Get list of fitting car models with optimal peak position, or
  actually the range that would still get accepted 
- If there's one in range, pick the middle one
- Value could optionally even be positive
- Now we have to synthesize the peak quality when re-inserting this
- Use the peak type (e.g. peak 3) to guess where the maxima should be
- Look for them
- Calculate qualities etc.
- Reject unless at least a good quality

Getting the gaps right
----------------------

findFirstLargeRange to process a list<Gap>&.
Stop at the first gap that meets the count goal.
Each gap is a single interval per non-zero interval in histogram.
guessNeighborDistance doesn't return a value.
If the list has length 1, it's clear.
If not, we need to try them out in order from below.
That means we look for number of pairs (each peak can only 
be used once) with good quality.
There can be other intervening peaks.


Efficiency
----------

Do sth about symm cars and efficiency of checking in general
- Has all four peaks, and dist(its reverse) < GREAT_DIST
- If matching two such cars, only use the forward distance
- Keep cars symmetrical that are meant to be so


PeakStructure:
- The distance detection / peak quality may also have to go here...

Python: Allow 082401 as input?

carDetect endValue, startValue: Drop the +1, -1 stuff again, deal
with in PeakStructure?

Clean up the PPc/const nonsense in PeakPool and PeakStructure.

* PeakMinima:
  - Some TODO's (algorithmic errors, actually)
  - The second guessLongGapDistance doesn't pick up anything,
    as the second peak is always a bogey already?


2018-09-14
----------
Maybe transients can be reduced with filter padding as in filtfilt.


2018-07-17
----------
Visual          OK 2019-05-28
gcc             OK 2019-05-28

mingw           OK 2018-07-17
Mac gcc
Mac clang
Linux

Overall algorithm
-----------------

* Check against laser measurements!
* Output a diagram with the wagons suggested
* filtfilt padding, how?
* Make independent of sample rate (other than Butterworth?)
* Move to less padding in SegQuiet back
* Implement displacement algorithms
  - Our integration
  - Some kind of scalar product
  - Estimate parameters of the flanks?  What kind of function?
  - Also add timers
* Float (Accel) to double everywhere
* Simpson integration?
* Deconvolution of a "wheel response"?
* Move out code in driver and directories that is not used

* Could have an average time delay or number of peaks missed by
  a given sensor.  See DEU_32.docx

* Missing a train type?  
  - sensor07 #1  173201.  30 of 32(?) peaks.

  - sensor27 #10 194415.  48 of 48(?) peaks.
    ICE1_DEU_52_N, symmetric: Consider to add this

Peak/car trouble in well-matching solutions:
s03, 173935, #31, 26.11
s07, 085335, #16,  0.28
s10, 200750, #32,  2.47
s19, 084253, #24,  0.83
s27, 194725, #29,  1.73

Peak/car trouble in poorly-matching but correct solutions:
s03, 085719, #28,  37.16
s04, 103039, # 8, 155.84
s08, 202150, #49,  12.34
s13, 083756, #17,  30.39
s18, 094628, #29, 177.77
s18, 185755, #30,   9.66
s18, 063210, #35,  15.65
s18, 075954, #42,  22.96
s18, 174241, #47, 238.43
s20, 102050, #41,   9.33
s21, 094236, #46,  27.75


Write a detector of unused class methods.
