Model updates don't have the right count, as some cars show up 
several times.  Could recalculate from scratch always.

Idea for whenever a new car arrives:

- Can only match within exact same gap pattern
- Can only match models with a match count > 0
- Can however match in reverse as well (log reverse flag in car)
- If it's not a downgrade:
  - Try to fill partial sides, don't touch models themselves yet
  - This may change several cars, actually
  - But we still assume that the models are fine
  - If it then matches
    - car: log stat index, distance
  - Else
    - add as a model
    - car: log as before
  - The other, changed cars if any are reclassified (first withdrawn)
  - Then recalculate all models based on the logged indices
    and the reverse flag
  - Some models now get a count of 0 and become inactive
  - When printing models, only the active ones
  - Also print the number of times that model is used

- Update ranges in general, whether or not a downgrade

ByQuality is in an in-between state.  Either turn on or delete.

PeakStructure:
- The distance detection / peak quality may also have to go here...

Python: Allow 082401 as input?

carDetect endValue, startValue: Drop the +1, -1 stuff again, deal
with in PeakStructure?

MISMATCH in "good" sensors:

sensor
sensor02        162222  #41     First car: Get 2 last peaks, not 1 last

sensor03        081132  #8      Inner: Only 3 peaks
                052036  #10     First 10 peaks: Take from behind
                                Inner: Only 3 peaks
                193754  #16     First: 1, maybe 2 peaks
                                Last: 5 peaks, 2 mislabeled early (new car)
                061240  #19     Whole front car missing! Close 4_48_{N,R}
                085719  #28     First: 4 great peaks (new car)
                                Inner: Only 3 peaks (twice)
                                Last: 4 great peaks (new car)
                173935  #31     First: 2 great peaks
                                Inner: Only 3 peaks
                                Last: 7 peaks = 3 + 4 great ones

sensor04        073931  #7      Wrong short gap, in-between neg. minimum!
sensor06        115207  #34     ICE4_DEU_48_{N,R} extremely similar

Clean up the PPc/const nonsense in PeakPool and PeakStructure.

* PeakMinima:
  - Some TODO's (algorithmic errors, actually)
  - The second guessLongGapDistance doesn't pick up anything,
    as the second peak is always a bogey already?


2018-09-17
----------
Give out the whole PeakList, don't copy into PeakTime?
Also output the likely number of missed front peaks


2018-09-14
----------
Maybe transients can be reduced with filter padding as in filtfilt.


2018-09-02
----------
* Add separate timers for pre-align and align
* And for peak extraction

* Clean up driver.cpp

2018-07-17
----------
* Some _N and _R trains are almost impossible to separate
  - ICE4_DEU_28 is probably symmetric, in fact?
  - ICE2_DEU_48 ditto?
  - ICE1_old_CHE_56 ditto? [delete?]
  - ICE4_DEU_28 and ICET_DEU_28 have extremely similar ratios

* In doc, make the comments from Train axles.xlsx

* Files to finish:
  SynthTrain cpp and h
  driver.cpp

Visual          OK
mingw           OK
gcc
Mac gcc
Mac clang
Linux

Overall algorithm
-----------------

* Check against laser measurements!
* Output a diagram with the wagons suggested
* filtfilt padding, how?
* Make independent of sample rate (other than Butterworth?)
* Move to less padding in SegQuiet back
* Implement displacement algorithms
  - Our integration
  - Some kind of scalar product
  - Estimate parameters of the flanks?  What kind of function?
  - Also add timers
* Float (Accel) to double everywhere
* Simpson integration?
* Deconvolution of a "wheel response"?
* Move out code in driver and directories that is not used
